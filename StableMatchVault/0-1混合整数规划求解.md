# 主要求解方法

## 分支定界法(Branch and Bound)
- 将原问题分解成若干子问题,通过设定上下界来缩小搜索空间
- 利用线性规划松弛解作为界限
- 按深度优先或广度优先策略进行分支搜索
- 根据界限值剪枝,提高求解效率
这是最基础也最常用的精确求解方法。其核心思想是通过不断划分解空间,并利用界限来剪除不可能包含最优解的子空间。具体工作过程如下：

首先将原整数规划问题的整数约束放松,求解一个线性规划问题,这给出了原问题的一个下界。如果这个解是整数解,那么就找到了最优解。否则,选择一个非整数变量xi,假设其值为a.5,创建两个子问题:一个添加约束xi ≤ ⌊a⌋,另一个添加约束xi ≥ ⌈a⌉。这个过程称为"分支"。

对每个子问题重复上述过程。如果某个子问题的最优值比已知的最好整数解差,或者子问题无解,就可以将该分支"剪掉",这就是"定界"。这种方法的效率很大程度上取决于分支变量的选择策略和界限的紧致性。

## 割平面法(Cutting Plane)
- 通过添加有效不等式(割平面)来逐步逼近整数可行解
- Gomory切割是最经典的割平面方法
- 可以与分支定界法结合,形成分支切割算法
割平面法的核心思想是通过添加新的约束条件(切割平面)来逐步将可行域收缩到整数可行解。这些切割平面要满足两个条件：不能切掉任何整数可行解,同时要切掉当前的非整数解。

最经典的是Gomory切割。假设我们有一个最优单纯形表,其中某个基本变量xi的值为非整数。通过对这个方程进行特殊的代数变换,可以得到一个有效的切割平面。添加这个切割后重新求解,直到得到整数解或者证明问题无解。

## 隐枚举法
- 通过对0-1变量的系统性枚举来搜索最优解
- 利用问题特征进行剪枝
- 适用于规模较小的问题
这是一种系统性地搜索所有可能的0-1组合的方法。它通过智能地安排搜索顺序和使用剪枝规则来提高效率。对于每个变量,我们考虑将其设为0或1的情况,这样就形成了一个决策树。

在搜索过程中,如果发现某个部分赋值已经违反了约束条件,或者得到的目标函数值已经比已知的最优解差,就可以停止对该分支的搜索。这种方法适合处理变量较少的问题。

## 启发式算法
- 遗传算法:通过变异和交叉操作搜索解空间
- 禁忌搜索:利用禁忌表避免陷入局部最优
- 模拟退火:以一定概率接受较差解,跳出局部最优
- 不保证得到全局最优解,但可以在较短时间内得到较好的可行解
当问题规模较大时,精确算法可能需要太长的计算时间。这时候启发式算法就显得特别重要。以遗传算法为例：

它模拟生物进化过程,维护一组解(称为种群)。每一代中,选择一些较好的解进行交叉(组合两个解的特征)和变异(随机改变解的某些位置)来产生新的解。随着代数增加,种群质量逐渐提高,最终得到一个较好的解。

## 分支切割法(Branch and Cut)
- 结合分支定界和割平面方法的优点
- 在分支过程中动态地加入切割平面
- 是目前最有效的精确求解方法之一
这是现代最有效的求解方法之一,它结合了分支定界法和割平面法的优点。在分支定界的框架下,在处理每个子问题时,尝试通过添加切割平面来改善松弛解的质量。

具体来说,当我们得到一个子问题的线性规划解时,首先尝试通过添加切割平面来得到更好的界限。如果添加切割平面后仍然得不到整数解,才进行分支。这样可以减少需要探索的节点数量。

## 分解方法
- Lagrange松弛法:将难求解的约束转化为目标函数的惩罚项
- Benders分解:将问题分解为主问题和子问题交替求解
- 适用于具有特殊结构的大规模问题
对于具有特殊结构的大规模问题,分解方法往往很有效。以Benders分解为例：

它将原问题分解为一个主问题(只包含整数变量)和若干子问题(固定整数变量后的连续规划问题)。通过主问题和子问题的反复求解,逐步改进解的质量。主问题给出整数变量的值,子问题检验这个解的可行性或给出改进的方向。

---
实际应用中,往往需要根据具体问题的规模和特点选择合适的求解方法。对于小规模问题,可以使用精确算法如分支定界法;对于大规模问题,可能需要使用启发式算法或分解方法来获得近似解。商业求解器(如CPLEX、Gurobi等)通常会集成多种算法,并根据问题特征自动选择最优的求解策略。

这些方法常常结合使用。例如,现代求解器通常会在分支切割法的框架下,结合使用预处理技术、启发式算法来加速求解过程。选择合适的求解方法需要考虑问题的规模、结构特点以及对解的质量和求解时间的要求。

---
# 各指标关系

| 算法方法  | 解的质量   | 计算复杂度        | 内存需求         | 问题规模 | 实现成本 | 并行效率 |
| ----- | ------ | ------------ | ------------ | ---- | ---- | ---- |
| 分支定界法 | 精确解    | O(2^n)       | O(2^n)       | 中小规模 | 中等   | 中等   |
| 割平面法  | 精确解    | O(n^3)/迭代    | O(n^2)       | 中等规模 | 较高   | 低    |
| 隐枚举法  | 精确解    | O(2^n)       | O(n)         | 小规模  | 低    | 低    |
| 启发式算法 | 近似解    | O(G×P×n)     | O(P×n)       | 大规模  | 中等   | 高    |
| 分支切割法 | 精确解    | O(2^n × n^3) | O(2^n + n^2) | 中大规模 | 高    | 中等   |
| 分解方法  | 精确/近似解 | O(I×(M+S))   | O(M+S)       | 大规模  | 高    | 高    |

以下是各指标的完整解释：

**解的质量**：反映算法能否保证获得全局最优解。精确算法（如分支定界法、割平面法、隐枚举法、分支切割法）能保证得到最优解；启发式算法只能得到近似最优解；分解方法则取决于具体实现方式。

**计算复杂度**：描述算法执行时间随问题规模增长的速度。指数级复杂度（如O(2^n)）的算法运行时间增长迅速，而多项式级复杂度（如O(n^3)）的算法扩展性较好。

**内存需求**：反映算法在执行过程中对计算机内存的占用程度。较低的空间复杂度（如O(n)）意味着算法更容易在有限内存条件下运行。

**问题规模**：表示算法能够有效处理的最大问题规模。这直接关系到算法的实用价值 - 启发式算法和分解方法适合处理大规模问题，而精确算法往往受限于较小的问题规模。

**实现成本**：衡量算法实现的技术难度和所需资源投入。简单算法（如隐枚举法）容易实现，而复杂算法（如分支切割法）需要更多的开发和调试工作。

**并行效率**：评估算法利用并行计算资源的潜力。良好的并行性（如启发式算法和分解方法）使算法能够充分利用现代计算架构提升性能。
![[算法指标.png]]
评分标准（1-5分制）：

| 维度 | 5分 | 4分 | 3分 | 2分 | 1分 |
|------|-----|-----|-----|-----|-----|
| 解的质量 | 精确解 | - | 精确/近似混合 | 近似解 | - |
| 计算复杂度 | 多项式级 | 拟多项式级 | 次指数级 | 指数级 | 超指数级 |
| 内存需求 | O(1) | O(n) | O(n^2) | O(2^n) | >O(2^n) |
| 问题规模 | 大规模 | 中大规模 | 中等规模 | 小规模 | 微小规模 |
| 实现成本 | 很容易 | 容易 | 中等 | 较难 | 很难 |
| 并行效率 | 极佳 | 良好 | 中等 | 较差 | 差 |
